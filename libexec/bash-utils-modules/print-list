#!/usr/bin/env bash-utils
#
# This script is a module for Bash-Utils
#
# bash-utils - A *bash* library for better scripting
# <http://gitlab.com/piwi/bash-utils>
# Copyright (c) 2015 Pierre Cassat & contributors
#
# Licensed under the Apache Software Foundation license, Version 2.0;
# you may not use this file except in compliance with the License.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# For sources & updates, see <http://gitlab.com/piwi/bash-utils>.
#
# To transmit bugs, see <http://gitlab.com/piwi/bash-utils/issues>.
#
# For the full copyright and license information, please view the LICENSE
# file that was distributed with this source code or see
# <http://www.apache.org/licenses/LICENSE-2.0>.
#

#### PRINT LIST ####

# you can define here a string about module's usage (short synopsis), description, name and version
CMD_NAME='Print-List'
CMD_VERSION='0.0.1'
CMD_SYNOPSIS="can't be called directly ; use 'use print-list; print_list <arguments>' in a script"
CMD_DESCRIPTION="print a 'user-friendly' list with a hand on output"
CMD_HELP=$(cat <<'MSG'
To use it in a script, run:
    use print-list
    print_list names[@] values[@] [headers[@]] [paddings[@]] [padders[@]] [separators[@]]

Full how to:

 - declare the list arrays for names and values
       declare -a LIST_NAMES=()
       declare -a LIST_VALUES=()

 - decalre list headers as an array (optional)
       declare -a LIST_HEADERS=('name' 'value')

 - add some name/value items
       LIST_NAMES[${#LIST_NAMES[@]}]='my name 1'
       LIST_VALUES[${#LIST_VALUES[@]}]='my value 1'

 - declare the list padders (characters used to fill blank spaces)
   - item [0] is padder for the separation line
   - item [1] is padder for contents lines
       declare -a LIST_PADDERS=()
       LIST_PADDERS[0]="$(printf '%0.1s' '-'{1..120})"
       LIST_PADDERS[1]="$(printf '%0.1s' ' '{1..120})"

 - declare the list paddings (number of space(s) from line to central separator)
   - item [0] is padding for the separation line
   - item [1] is padding for contents lines
       declare -a LIST_PADDINGS=(0 1)

 - declare the list separators (characters used to separate cells)
   - item [0] is the separator for the separation line
   - item [1] is the separator for contents lines
       declare -a LIST_SEPARATORS=('+' '|')

 - call the 'print_list' method with all variables:
       print_list LIST_NAMES[@] LIST_VALUES LIST_HEADERS[@] LIST_PADDINGS[@] LIST_PADDERS[@] LIST_SEPARATORS[@]

MSG
);

## !! REQUIRED !! ## stop here on pre-loading
if ${PRELOAD:-false}; then return 0; fi

#######################
## module's logic, library ...

# print a list with optional headers
#
# how to:
#
# - declare the list arrays for names and values
#       declare -a LIST_NAMES=()
#       declare -a LIST_VALUES=()
#
# - decalre list headers as an array (optional)
#       declare -a LIST_HEADERS=('name' 'value')
#
# - add some name/value items
#       LIST_NAMES[${#LIST_NAMES[@]}]='my name 1'
#       LIST_VALUES[${#LIST_VALUES[@]}]='my value 1'
#
# - declare the list padders (characters used to fill blank spaces)
#   - item [0] is padder for the separation line
#   - item [1] is padder for contents lines
#       declare -a LIST_PADDERS=()
#       LIST_PADDERS[0]="$(printf '%0.1s' "-"{1..120})"
#       LIST_PADDERS[1]="$(printf '%0.1s' " "{1..120})"
#
# - declare the list paddings (number of space(s) from line to central separator)
#   - item [0] is padding for the separation line
#   - item [1] is padding for contents lines
#       declare -a LIST_PADDINGS=(0 1)
#
# - declare the list separators (characters used to separate cells)
#   - item [0] is the separator for the separation line
#   - item [1] is the separator for contents lines
#       declare -a LIST_SEPARATORS=('+' '|')
#
# - call the `print_list` method with all variables:
#       print_list LIST_NAMES[@] LIST_VALUES LIST_HEADERS[@] LIST_PADDINGS[@] LIST_PADDERS[@] LIST_SEPARATORS[@]
#
# usage: `print_list <names[@]> <values[@]> <headers[@]> <paddings[@]> <padders[@]> <separators[@]>`
print_list()
{
    [ $# -lt 2 ] && return 0;
    declare -ax _LIST_NAMES _LIST_VALUES _LIST_HEADERS _LIST_PADDINGS _LIST_PADDERS _LIST_SEPARATORS _LIST_LENGTHS _ITEM_NAME _ITEM_VALUE
    _LIST_NAMES=("${!1}")
    _LIST_VALUES=("${!2}")
    [ $# -gt 2 ] && _LIST_HEADERS=("${!3}")    || _LIST_HEADERS=();
    [ $# -gt 3 ] && _LIST_PADDINGS=("${!4}")   || _LIST_PADDINGS=(0 1);
    [ $# -gt 4 ] && _LIST_PADDERS=("${!5}")    || _LIST_PADDERS=("$(printf '%0.1s' "-"{1..120})" "$(printf '%0.1s' " "{1..120})");
    [ $# -gt 5 ] && _LIST_SEPARATORS=("${!6}") || _LIST_SEPARATORS=('+' '|');
    # get lengths
    _LIST_LENGTHS=(0 0)
    for ((j=0; j<2; j++)); do
        if [ ${#_LIST_HEADERS[$j]} -gt "${_LIST_LENGTHS[0]}" ]; then
            _LIST_LENGTHS[0]=${#_LIST_HEADERS[$j]}
        fi
    done
    for ((j=0; j<"${#_LIST_NAMES[@]}"; j++)); do
        if [ ${#_LIST_NAMES[$j]} -gt "${_LIST_LENGTHS[0]}" ]; then
            _LIST_LENGTHS[0]=${#_LIST_NAMES[$j]}
        fi
    done
    for ((j=0; j<"${#_LIST_VALUES[@]}"; j++)); do
        if [ ${#_LIST_VALUES[$j]} -gt "${_LIST_LENGTHS[1]}" ]; then
            _LIST_LENGTHS[1]=${#_LIST_VALUES[$j]}
        fi
    done
    # print headers line if so
    if [ "${#_LIST_HEADERS[@]}" -gt 0 ]; then
        # print headers line
        print_list_line "${_LIST_HEADERS[0]}" "${_LIST_HEADERS[1]}"
        # print separator line
        print_list_separator_line
    fi
    # print each line
    for ((j=0; j<"${#_LIST_NAMES[@]}"; j++)); do
        print_list_line "${_LIST_NAMES[$j]}" "${_LIST_VALUES[$j]}"
    done
    return 0
}

# print one line of a list
# called by `print_list()`
# usage: `print_list_line <name> <value>`
print_list_line()
{
    [ $# -lt 2 ] && return 0;
    _ITEM_NAME="${1}"
    _ITEM_VALUE="${2}"
    line="$(printf "%*.*s%s%*.*s%s%*.*s%s%*.*s" \
        0 $((_LIST_LENGTHS[0] - ${#_ITEM_NAME})) "${_LIST_PADDERS[1]}" \
        "${_ITEM_NAME}" \
        0 "${_LIST_PADDINGS[1]}" "${_LIST_PADDERS[1]}" \
        "${_LIST_SEPARATORS[1]}" \
        0 "${_LIST_PADDINGS[1]}" "${_LIST_PADDERS[1]}" \
        "${_ITEM_VALUE}" \
        0 $((_LIST_LENGTHS[1] - ${#_ITEM_NAME})) "${_LIST_PADDERS[1]}" \
    )";
    echo "$line"
    return 0
}

# print a separation line of a list
# called by `print_list()`
# usage: `print_list_separator_line`
print_list_separator_line()
{
    local line
    line="$(printf "%*.*s%*.*s%s%*.*s%*.*s" \
        0 $((_LIST_LENGTHS[0] + _LIST_PADDINGS[1] - _LIST_PADDINGS[0])) "${_LIST_PADDERS[0]}" \
        0 "${_LIST_PADDINGS[0]}" "${_LIST_PADDERS[1]}" \
        "${_LIST_SEPARATORS[0]}" \
        0 "${_LIST_PADDINGS[0]}" "${_LIST_PADDERS[1]}" \
        0 $((_LIST_LENGTHS[1] + _LIST_PADDINGS[1] - _LIST_PADDINGS[0])) "${_LIST_PADDERS[0]}" \
    )";
    echo "$line"
    return 0
}

#######################
## treat direct params ...

# called params should be treated directly for direct calls
if [ $# -gt 0 ] || [ -n "$CMD_MODULE" ]; then
    rearrange_options "$@"
    [ -n "$CMD_REQ" ] && eval set -- "$CMD_REQ";
    common_options "$@"
    $DEBUG && debug;
    usage_info
fi

#######################
# a module should always exit or return with a status (0 for no error)
[ "$(basename "$0")" = "$(basename "${BASH_SOURCE[0]}")" ] && exit 0 || return 0;

## vim default shell setup (must be the very last line):
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=sh
