#!/usr/bin/env bash-utils
#
# This script is a module for Bash-Utils
#
# --------
#
# bash-utils - A *bash* library for better scripting
# <http://github.com/piwi/bash-utils>
# Copyright (c) 2015 Pierre Cassat & contributors
#
# This program is free software: you can freely use it, redistribute it
# and/or modify it according to your needs, for yourself or a commercial use,
# under the terms of the Apache License version 2.0 (the "License") as
# published by the Apache Software Foundation.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# The sources of this program are hosted on a public repository.
# You can modify it, to ameliorate a feature or correct an error,
# inform about a bug and follow updates at <http://github.com/piwi/bash-utils>.
#
# You should have received a copy of the License along with this program ;
# please see the LICENSE file that was distributed with this source code.
# If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
#

#### PRINT TABLE ####

# you can define here a string about module's usage (short synopsis), description, name and version
CMD_NAME='Print-Table'
CMD_VERSION='0.0.1'
CMD_SYNOPSIS="can't be called directly ; you should write 'use print-table; print_table <arguments>' in a script"
CMD_DESCRIPTION="print a 'user-friendly' table with a hand on output"
CMD_HELP=$(cat <<'MSG'
To use it in a script, run:
    use print-table
    print_table names[@] values[@] [headers[@]] [paddings[@]] [padders[@]] [separators[@]]

Full how to:

 - declare the table array
       declare -a TABLE_ITEMS=()

 - declare the table padders (characters used to fill blank spaces)
   - item [0] is padder for separation lines cells
   - item [1] is padder for contents lines cells
       declare -a TABLE_PADDERS=()
       TABLE_PADDERS[0]="$(printf '%0.1s' "-"{1..120})"
       TABLE_PADDERS[1]="$(printf '%0.1s' " "{1..120})"

 - declare the table paddings (number of space(s) from line to cell\'s contents)
   - item [0] is padding for separation lines cells
   - item [1] is padding for contents lines cells
       declare -a TABLE_PADDINGS=()
       TABLE_PADDINGS[0]=0
       TABLE_PADDINGS[1]=1

 - declare the table separators (characters used to separate cells)
   - item [0] is the separator for separation lines
   - item [1] is the separator for contents lines
       declare -a TABLE_SEPARATORS=('+' '|')

 - declare the table headers as an array
       declare -a TABLE_HEADERS=( "name" "value" "comment" )

 - add each line of the table as an array, declared itself as another array
       declare -a ITEM_0=("my name1" "my value1" "my comment1")
       TABLE_ITEMS[${#TABLE_ITEMS[@]}]=ITEM_0[@]

 - call the 'print_table' method with all variables:
       print_table TABLE_ITEMS[@] TABLE_HEADERS[@] TABLE_PADDINGS[@] TABLE_PADDERS[@] TABLE_SEPARATORS[@]

MSG
);

## !! REQUIRED !! ## stop here on pre-loading
if ${PRELOAD:-false}; then return 0; fi

#######################
## module's logic, library ...

# print a table with optional headers
#
# how to:
#
# - declare the table array
#       declare -a TABLE_ITEMS=()
#
# - declare the table padders (characters used to fill blank spaces)
#   - item [0] is padder for separation lines cells
#   - item [1] is padder for contents lines cells
#       declare -a TABLE_PADDERS=()
#       TABLE_PADDERS[0]="$(printf '%0.1s' "-"{1..120})"
#       TABLE_PADDERS[1]="$(printf '%0.1s' " "{1..120})"
#
# - declare the table paddings (number of space(s) from line to cell's contents)
#   - item [0] is padding for separation lines cells
#   - item [1] is padding for contents lines cells
#       declare -a TABLE_PADDINGS=()
#       TABLE_PADDINGS[0]=0
#       TABLE_PADDINGS[1]=1
#
# - declare the table separators (characters used to separate cells)
#   - item [0] is the separator for separation lines
#   - item [1] is the separator for contents lines
#       declare -a TABLE_SEPARATORS=('+' '|')
#
# - declare the table headers as an array
#       declare -a TABLE_HEADERS=( "name" "value" "comment" )
#
# - add each line of the table as an array, declared itself as another array
#       declare -a ITEM_0=("my name1" "my value1" "my comment1")
#       TABLE_ITEMS[${#TABLE_ITEMS[@]}]=ITEM_0[@]
#
# - call the `print_table` method with all variables:
#       print_table TABLE_ITEMS[@] TABLE_HEADERS[@] TABLE_PADDINGS[@] TABLE_PADDERS[@] TABLE_SEPARATORS[@]
#
# usage: `print_table <items[@]> <headers[@]> <paddings[@]> <padders[@]> <separators[@]>`
print_table()
{
    [ $# -eq 0 ] && return 0;
    declare -xa _TABLE_ITEMS _TABLE_HEADERS _TABLE_PADDERS _TABLE_PADDINGS _TABLE_SEPARATORS _TABLE_ITEM _TABLE_LENGTHS
    _TABLE_ITEMS=("${!1}")
    [ $# -gt 1 ] && _TABLE_HEADERS=("${!2}")    || _TABLE_HEADERS=();
    [ $# -gt 2 ] && _TABLE_PADDINGS=("${!3}")   || _TABLE_PADDINGS=(0 1);
    [ $# -gt 3 ] && _TABLE_PADDERS=("${!4}")    || _TABLE_PADDERS=("$(printf '%0.1s' "-"{1..120})" "$(printf '%0.1s' " "{1..120})");
    [ $# -gt 4 ] && _TABLE_SEPARATORS=("${!5}") || _TABLE_SEPARATORS=('+' '|');
    # get length for each column
    local i j
    _TABLE_LENGTHS=()
    if [ "${#_TABLE_HEADERS[@]}" -gt 0 ]; then
        for ((j=0; j<"${#_TABLE_HEADERS[@]}"; j++)); do
            if [ ! "${_TABLE_LENGTHS[$j]+x}" ] || [ ${#_TABLE_HEADERS[$j]} -gt "${_TABLE_LENGTHS[$j]}" ]; then
                _TABLE_LENGTHS[$j]=${#_TABLE_HEADERS[$j]}
            fi
        done
    fi
    for ((i=0; i<"${#_TABLE_ITEMS[@]}"; i++)); do
        _TABLE_ITEM=("${!_TABLE_ITEMS[$i]}")
        for ((j=0; j<"${#_TABLE_ITEM[@]}"; j++)); do
            if [ ! "${_TABLE_LENGTHS[$j]+x}" ] || [ ${#_TABLE_ITEM[$j]} -gt "${_TABLE_LENGTHS[$j]}" ]; then
                _TABLE_LENGTHS[$j]=${#_TABLE_ITEM[$j]}
            fi
        done
    done
    # print headers line if so
    if [ "${#_TABLE_HEADERS[@]}" -gt 0 ]; then
        # print separator line
        print_table_separator_line
        # print headers line
        print_table_line _TABLE_HEADERS[@]
    fi
    # print first contents' separator line
    print_table_separator_line
    # print each contents line
    for ((i=0; i<"${#_TABLE_ITEMS[@]}"; i++)); do
        _TABLE_ITEM=("${!_TABLE_ITEMS[$i]}")
        print_table_line _TABLE_ITEM[@]
    done
    # print last contents' separator line
    print_table_separator_line
    return 0
}

# print one line of a table
# called by `print_table()`
# usage: `print_table_line <item[@]>`
print_table_line()
{
    [ $# -eq 0 ] && return 0;
    _TABLE_ITEM=("${!1}")
    local line value j
    line=''
    for ((j=0; j<"${#_TABLE_LENGTHS[@]}"; j++)); do
        value=''
        [ "${_TABLE_ITEM[$j]+x}" ] && value="${_TABLE_ITEM[$j]}";
        line+="$(printf '%*.*s%s%*.*s%s' \
            0 "${_TABLE_PADDINGS[1]}" "${_TABLE_PADDERS[1]}" \
            "$value" \
            0 $((_TABLE_LENGTHS[j] + _TABLE_PADDINGS[1] - ${#_TABLE_ITEM[$j]})) "${_TABLE_PADDERS[1]}" \
            "${_TABLE_SEPARATORS[1]}" \
        )";
    done
    echo "${_TABLE_SEPARATORS[1]}${line}"
    return 0
}

# print a separation line of a table
# called by `print_table()`
# usage: `print_table_separator_line`
print_table_separator_line()
{
    local line=''
    for ((j=0; j<"${#_TABLE_LENGTHS[@]}"; j++)); do
        line+="$(printf '%*.*s%*.*s%*.*s%s' \
            0 "${_TABLE_PADDINGS[0]}" "${_TABLE_PADDERS[1]}" \
            0 $((_TABLE_LENGTHS[j] + (2 * _TABLE_PADDINGS[1]) - (2 * _TABLE_PADDINGS[0]) )) "${_TABLE_PADDERS[0]}" \
            0 "${_TABLE_PADDINGS[0]}" "${_TABLE_PADDERS[1]}" \
            "${_TABLE_SEPARATORS[0]}" \
        )";
    done
    echo "${_TABLE_SEPARATORS[0]}${line}"
    return 0
}

#######################
## treat direct params ...

# called params should be treated directly for direct calls
if [ $# -gt 0 ] || [ -n "$CMD_MODULE" ]; then
    rearrange_options "$@"
    [ -n "$CMD_REQ" ] && eval set -- "$CMD_REQ";
    common_options "$@"
    $DEBUG && debug;

#set -o noglob
#[ $# -gt 0 ] && print_table "$*";
#if [ $# -gt 0 ]; then
#    declare -a TABLE_ITEMS TABLE_HEADERS TABLE_PADDERS TABLE_PADDINGS TABLE_SEPARATORS
#    TABLE_ITEMS=("${!1}")
#    [ $# -gt 1 ] && TABLE_HEADERS=("${!2}")    || TABLE_HEADERS=();
#    [ $# -gt 2 ] && TABLE_PADDINGS=("${!3}")   || TABLE_PADDINGS=(0 1);
#    [ $# -gt 3 ] && TABLE_PADDERS=("${!4}")    || TABLE_PADDERS=("$(printf '%0.1s' "-"{1..120})" "$(printf '%0.1s' " "{1..120})");
#    [ $# -gt 4 ] && TABLE_SEPARATORS=("${!5}") || TABLE_SEPARATORS=('+' '|');
#    print_table TABLE_ITEMS[@] TABLE_HEADERS[@] TABLE_PADDINGS[@] TABLE_PADDERS[@] TABLE_SEPARATORS[@]
#fi

    usage_info
fi

#######################
# a module should always exit or return with a status (0 for no error)
[ "$(basename "$0")" = "$(basename "${BASH_SOURCE[0]}")" ] && exit 0 || return 0;

## vim default shell setup (must be the very last line):
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=sh
