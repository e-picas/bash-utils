#!/usr/bin/env bash-utils
#
# This script is a module for Bash-Utils
#
# bash-utils - A *bash* library for better scripting
# <http://gitlab.com/piwi/bash-utils>
# Copyright (c) 2015 Pierre Cassat & contributors
#
# Licensed under the Apache Software Foundation license, Version 2.0;
# you may not use this file except in compliance with the License.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# For sources & updates, see <http://gitlab.com/piwi/bash-utils>.
#
# To transmit bugs, see <http://gitlab.com/piwi/bash-utils/issues>.
#
# For the full copyright and license information, please view the LICENSE
# file that was distributed with this source code or see
# <http://www.apache.org/licenses/LICENSE-2.0>.
#

#original getopt():
#-l, --longoptions longopts
#-n, --name progname
#-o, --options shortopts

##@!@##
#### SCRIPT OPTIONS / ARGUMENTS #############################################################################

##@ ORIGINAL_SCRIPT_OPTS="$@" (read-only)
## Original list of raw command line arguments
declare -rx ORIGINAL_SCRIPT_OPTS="$@"
##@ SCRIPT_PARAMS=''
## String of re-arranged parameters (options & arguments)
declare -x SCRIPT_PARAMS=''
##@ SCRIPT_PIPED_INPUT=''
## String of any piped content from previous command
declare -x SCRIPT_PIPED_INPUT=''
##@ SCRIPT_OPTS=()
## Array of options with arguments
declare -xa SCRIPT_OPTS=()
##@ SCRIPT_ARGS=()
## Array of script's arguments
declare -xa SCRIPT_ARGS=()
##@ SCRIPT_OPTS_ERRS=()
## Array of options errors
declare -ax SCRIPT_OPTS_ERRS=()
##@ ARGIND
## Integer of current argument index
declare -xi ARGIND=0
##@ ARGUMENT
## Current argument string (see `ARGIND`)
declare -x ARGUMENT=''

## Options errors messages
declare -rx UNKNOWN_OPTION_MASK="unknown option '%s'!"
declare -rx MISSING_OPTION_ARGUMENT_MASK="option '%s' requires an argument!"

# usage: `read_from_pipe [file=/dev/stdin]`
read_from_pipe()
{
    local fpipe fpipedir
    fpipe="${1:-/dev/stdin}"
    fpipedir="$(dirname "$fpipe")"
    if [ -e "$fpipe" ] && [ -p "$fpipe" ]; then
#        while [[ -L "$fpipe" ]]; do
#            fpipe="$(readlink "$fpipe")"
#            if [ ! -e "$fpipe" ]; then
#                fpipe="${fpipedir}/${fpipe}"
#            fi
#        done
        SCRIPT_PIPED_INPUT="$(cat "$fpipe")"
    fi
    export SCRIPT_PIPED_INPUT
}

## stop here on pre-loading
if ${PRELOAD:-false}; then return 0; fi

# usage: `get_short_options_array [short_opts=OPTIONS_ALLOWED]`
get_short_options_array()
{
    local shortopts="${1:-${OPTIONS_ALLOWED}}"
    local -a short_options=()
    local shortoptions="${shortopts//-:/}"
    explode_letters "$shortoptions"
    local b=''
    for i in "${EXPLODED_ARRAY[@]}"; do
        if [ "$i" = ':' ] && [ -n "$b" ]; then
            b="${b}${i}"
        elif [ "$i" != '-' ]; then
            [ -n "$b" ] && short_options+=( "$b" );
            b="$i"
        else
            [ -n "$b" ] && short_options+=( "$b" );
            b=''
        fi
    done
    [ -n "$b" ] && short_options+=( "$b" );
    echo "${short_options[@]}"
    return 0
}

# usage: `get_short_options_string [delimiter='|'] [short_opts=OPTIONS_ALLOWED]`
get_short_options_string()
{
    local delimiter="${1:-|}"
    local shortopts="${2:-${OPTIONS_ALLOWED}}"
    local -a short_options=( $(get_short_options_array "$shortopts") )
    implode short_options[@] "${delimiter}"
    return 0
}

# usage: `get_option_declaration <option_name> [short_opts=OPTIONS_ALLOWED]`
get_option_declaration()
{
    local _optname="$1"
    local shortopts="${2:-${OPTIONS_ALLOWED}}"
    local -a opts_table=( $(get_options_array "$shortopts") )
    local optiondef_ind=$(array_search "$_optname" "${opts_table[@]}")
    [ -z "$optiondef_ind" ] && optiondef_ind=$(array_search "${_optname}:" "${opts_table[@]}");
    [ -z "$optiondef_ind" ] && optiondef_ind=$(array_search "${_optname}::" "${opts_table[@]}");
    echo "${opts_table[${optiondef_ind}]}"
    return 0
}

# echoes the argument of an option
# usage: `get_option_arg "$x"`
get_option_arg()
{
    if [ -n "$1" ]; then echo "${1#=}"; fi; return 0;
}

# usage: `get_long_options_array [long_opts=LONG_OPTIONS_ALLOWED]`
get_long_options_array()
{
    local longopts="${1:-${LONG_OPTIONS_ALLOWED}}"
    local -a long_options=()
    explode "$longopts" ","
    for i in "${EXPLODED_ARRAY[@]}"; do
        long_options+=( "$i" )
    done
    echo "${long_options[@]}"
    return 0
}

# usage: `get_long_options_string [delimiter='|'] [long_opts=LONG_OPTIONS_ALLOWED]`
get_long_options_string()
{
    local delimiter="${1:-|}"
    local longopts="${2:-${LONG_OPTIONS_ALLOWED}}"
    local -a long_options=( $(get_long_options_array "$longopts") )
    implode long_options[@] "$delimiter"
    return 0
}

# usage: `get_long_option_declaration <option_name> [long_opts=LONG_OPTIONS_ALLOWED]`
get_long_option_declaration()
{
    local _optname="$1"
    local longopts="${2:-${LONG_OPTIONS_ALLOWED}}"
    local -a opts_table=( $(get_long_options_array "$longopts") )
    local optiondef_ind=$(array_search "$_optname" "${opts_table[@]}")
    [ -z "$optiondef_ind" ] && optiondef_ind=$(array_search "${_optname}:" "${opts_table[@]}");
    [ -z "$optiondef_ind" ] && optiondef_ind=$(array_search "${_optname}::" "${opts_table[@]}");
    echo "${opts_table[${optiondef_ind}]}"
    return 0
}

# echoes the name of a long option
# usage: `get_long_option_name "$x"`
get_long_option_name()
{
    local arg="$1"
    if [ -n "$arg" ]; then
        if [[ "$arg" =~ .*=.* ]]; then arg="${arg%=*}"; fi
        echo "$arg" | cut -d " " -f1
        return 0
    fi
    return 1
}

# echoes the argument of a long option
# usage: `get_long_option_arg "$x"`
get_long_option_arg()
{
    local arg=''
    local argstr="$1"
    if [ -n "$argstr" ]; then
        [[ "$argstr" =~ .*\ .* ]] && arg="$(echo "$argstr" | cut -d " " -f2-)";
        [[ "$argstr" =~ .*=.* ]] && arg="${argstr#*=}";
        [[ "$argstr" != "$arg" ]] && echo "$arg";
        return 0
    fi
    return 1
}

##@ LONGOPTNAME=''
## The name of current long option treated
declare -x LONGOPTNAME=''
##@ LONGOPTARG=''
## The argument set for current long option
declare -x LONGOPTARG=''

# This will parse and retrieve the name and argument of current long option.
# usage: `parse_long_option <$OPTARG> <${!OPTIND}>`
parse_long_option()
{
    [ $# -eq 0 ] && return 1;
    local _optarg="$1"
    local _nextarg="${2:-}"
    LONGOPTNAME="$(get_long_option "$_optarg")"
    LONGOPTARG="$(get_long_option_arg "$_optarg")"
    local optiondef="$(get_long_option_declaration "$LONGOPTNAME")"
#    if [ -z "$LONGOPTARG" ] && [ "${optiondef: -1}" = ':' ] && [ "${optiondef: -2}" != '::' ]; then
    if [ -z "$LONGOPTARG" ] && [ "${optiondef: -1}" = ':' ]; then
        LONGOPTARG="$_nextarg"
        ((OPTIND++))
    fi
    LONGOPTARG="$(echo "$LONGOPTARG" | sed -e "s/^'//" -e "s/'$//")"
    export LONGOPTNAME LONGOPTARG OPTIND
    return 0
}

# method to loop over command line's arguments just like `getopts` does for options
# this will load current argument's value in `VAR_NAME` and increment `ARGIND` at each turn
# usage: `getargs <VAR_NAME>`
getargs()
{
    local argvar="${1:-ARGUMENT}"
    shiftarg
    local _status=$?
    if [ "$ARGIND" -eq 0 ]||[ "$_status" -ne 0 ]; then
        return 1
    fi
    if [ "$argvar" != 'ARGUMENT' ]; then
        eval "export $argvar=\"$ARGUMENT\"";
    fi
    return 0
}

# get next script argument according to current `ARGIND`
# load it in `ARGUMENT` and let `ARGIND` incremented
# usage: `shiftarg`
shiftarg()
{
    local argsnum="${#SCRIPT_ARGS[@]}"
    if [ "${#SCRIPT_ARGS[@]}" -gt 0 ] && [ "$ARGIND" -lt "$((argsnum + 1))" ]
    then
        ARGUMENT="${SCRIPT_ARGS[$((ARGIND - 1))]}"
        ((ARGIND++))
        export ARGIND ARGUMENT
        return 0
    else
        return 1
    fi
}

# usage: `rearrange_request_new "$0" "$@"`
rearrange_request_new()
{
    getopt --test > /dev/null
    local _vers="$?"
    if [ -n "$_vers" ] && [ "$_vers" -ne 4 ]; then
        verecho "> your version of 'getopt' seems to be old! Processing alternative 'rearrange_request()' method."
        rearrange_request "$@"
        return 0
    fi
    local progname="$1"
    shift
    # use '--alernative' option to allow single dash for long options
    SCRIPT_PARAMS="$(getopt --quiet --shell 'bash' --options "$OPTIONS_ALLOWED" --longoptions "$LONG_OPTIONS_ALLOWED" --name "$progname" -- "$@")"
    local _ret="$?"
    case "$_ret" in
        2) error "an internal 'getopt' error occurred!";;
        3) error "an internal error occurred while calling 'getopt'!";;
    esac
    if [ "$SCRIPT_PARAMS" = ' --' ]; then SCRIPT_PARAMS=''; fi
    export SCRIPT_PARAMS
    eval set -- "$SCRIPT_PARAMS"
    rearrange_request "$@"
    return 0
}

# this will separate script options from script arguments (emulation of GNU "getopt")
# options are loaded in $SCRIPT_OPTS with their arguments
# arguments are loaded in $SCRIPT_ARGS
# usage: `rearrange_request "$@"`
rearrange_request()
{
    SCRIPT_OPTS=()
    SCRIPT_ARGS=()
    local oldoptind="$OPTIND"
    local -a params=( "$@" )
    local numargs="${#params[@]}"
    local -a longopts_table=( $(get_long_options_array) )
    local firstoptdone=false
    local firstchar
    local arg
    if [ -z "$SCRIPT_PARAMS" ]; then
        for i in "${!params[@]}"; do
            arg="${params[${i}]}"
            firstchar="${arg:0:1}"
            if [ "$firstchar" != "-" ]
                then SCRIPT_ARGS+=( "$arg" )
                elif [ "$firstoptdone" != 'true' ]; then firstoptdone=true;
            fi
            if [ "$firstoptdone" != 'true' ]; then unset params["$i"]; fi
        done
    fi
    OPTIND=1
    local eoo=false
    while getopts ":${OPTIONS_ALLOWED}" OPTION "${params[@]-}"; do
        OPTNAME="$OPTION"
        OPTARG="$(get_option_arg "${OPTARG:-}")"
        local argindex=false
        case "$OPTNAME" in
            -)  LONGOPTNAME="$(get_long_option "$OPTARG")"
                LONGOPTARG="$(get_long_option_arg "$OPTARG")"
                optiondef=$(get_long_option_declaration "$LONGOPTNAME")
                if [ -z "$LONGOPTARG" ] && [ "${optiondef: -1}" = ':' ]; then
                    if [ -z "$SCRIPT_PARAMS" ]; then
                        ((OPTIND++))
                    fi
                    if [ "${!OPTIND:0:1}" != '-' ]
                    then
                        LONGOPTARG="${!OPTIND}"
                        if [ -n "$SCRIPT_PARAMS" ]; then
                            ((OPTIND++))
                        fi
                    fi
                fi
                case "$LONGOPTNAME" in
                    -)  eoo=true;
                        ((OPTIND++))
                        break;;
                    *)  if [ ! -z "$LONGOPTARG" ] && [ "$LONGOPTNAME" != "$LONGOPTARG" ]; then
                            SCRIPT_OPTS+=( "--${LONGOPTNAME}='${LONGOPTARG}'" )
                            SCRIPT_ARGS=( "${SCRIPT_ARGS[@]//${LONGOPTARG}}" )
                        else
                            SCRIPT_OPTS+=( "--${LONGOPTNAME}" )
                        fi;;
                esac ;;
            \?)
                SCRIPT_ARGS+=( "-${OPTION}" )
                ;;
            *)  if [ "$eoo" != 'true' ]; then
                    if [ ! -z "$OPTARG" ]; then
                        SCRIPT_OPTS+=( "-${OPTION}='${OPTARG}'" )
                        SCRIPT_ARGS=( "${SCRIPT_ARGS[@]//${OPTARG}}" )
                    else
                        SCRIPT_OPTS+=( "-${OPTION}" )
                    fi
                fi;;
        esac
    done
    if [ -z "$SCRIPT_PARAMS" ]; then
        ((OPTIND++))
    fi
    while [ "$OPTIND" -lt $((numargs + 1)) ]; do
        if [ "${!OPTIND}" != '--' ]; then
            if [ -z "$SCRIPT_PARAMS" ]; then
                SCRIPT_ARGS=( "${SCRIPT_ARGS[@]//${!OPTIND}}" )
            fi
            SCRIPT_ARGS+=( "${!OPTIND}" )
        fi
        ((OPTIND++))
    done
    OPTIND="$oldoptind"
    SCRIPT_ARGS=( $(array_filter "${SCRIPT_ARGS[@]-}") )
    if [ -z "$SCRIPT_PARAMS" ]; then
        if [ "${#SCRIPT_OPTS[@]}" -gt 0 ] && [ "${#SCRIPT_ARGS[@]}" -eq 0 ];
            then SCRIPT_PARAMS="${SCRIPT_OPTS[*]}";
        elif [ "${#SCRIPT_OPTS[@]}" -eq 0 ] && [ "${#SCRIPT_ARGS[@]}" -gt 0 ];
            then SCRIPT_PARAMS="${SCRIPT_ARGS[*]}";
        elif [ "${#SCRIPT_OPTS[@]}" -gt 0 ] && [ "${#SCRIPT_ARGS[@]}" -gt 0 ];
            then SCRIPT_PARAMS="${SCRIPT_OPTS[*]} -- ${SCRIPT_ARGS[*]}";
        fi
    fi
    ARGIND=0
    export OPTIND ARGIND SCRIPT_OPTS SCRIPT_ARGS SCRIPT_PARAMS
    return 0
}

# treat direct params
[ $# -gt 0 ] && rearrange_request_new "$@";

##@!@##
[ "$(basename "$0")" = "$(basename "${BASH_SOURCE[0]}")" ] && exit 0 || return 0;
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=sh
